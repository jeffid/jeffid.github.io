[{"categories":["后端"],"content":"背景 单例模式可以说是最简单的设计模式之一了，功能很简单：一个类型的东西只实例化一次，全局只有一个实例，并提供方法来获取该实例。 在 Golang 中变量或说明实例只初始化一次的效果通过init函数是可以实现的，包在被引入时就会执行一次init函数且无论同一包被引入多少次也都只执行一次。 不过本文主要想讨论的单例模式是第一次需要用到时才去初始化，也就是延迟初始化。 ","date":"2022-10-01","objectID":"/112_glang-singleton/:1:0","tags":["Golang","设计模式"],"title":"Golang 单例模式与sync.Once","uri":"/112_glang-singleton/"},{"categories":["后端"],"content":"不太好的单例实现 // bad_singleton.go package main import ( \"sync\" ) var svcMu sync.Mutex var svc *Svc type Svc struct { Num int } func GetSvc() *Svc { if svc == nil { // 这一步判断不是并发安全的 svcMu.Lock() defer svcMu.Unlock() if svc == nil { svc = \u0026Svc{Num: 1} svc = \u0026Svc{} svc.Num = 1 } } return svc } 注意执行互斥锁svcMu.Lock()前的语句if svc == nil 并不是并发安全的，即在多个 goroutine 并发调用的场景下，其中的一个 goroutine 正在初始化这个变量svc的过程中，这里别的 goroutine 判断得到svc不等于nil的结果时也并不意味着svc就一定完成初始化了。 因为在缺乏显式同步的情况下，编译器和CPU在能保证每个 goroutine 内满足串行一致性的基础上可以自由地重排访问内存的指令顺序。 比如svc = \u0026Svc{Num: 1}这行看上去只是一条执行语句，可能重排后的一种实现是像下面这样的： svc = \u0026Svc{} svc.Num = 1 可见，不等于nil并不意味着就一定完成了初始化，因此上面示例是一种不太好的单例实现。 ","date":"2022-10-01","objectID":"/112_glang-singleton/:2:0","tags":["Golang","设计模式"],"title":"Golang 单例模式与sync.Once","uri":"/112_glang-singleton/"},{"categories":["后端"],"content":"比较好的单例实现 // good_singleton.go package main import ( \"sync\" ) var svcOnce sync.Once var svc *Svc type Svc struct { Num int } func GetSvc() *Svc { svcOnce.Do(func() { svc = \u0026Svc{Num: 1} }) return svc } sync.Once提供的Do方法无论被调用多少次都只执行传入的函数一次，那为什么说直接使用Do方法执行初始化而不是套一层if svc == nil 才是比较好的做法呢，下面结合sync.Once源码来说明。 // sync.Once 源码 package sync import ( \"sync/atomic\" ) type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { if atomic.LoadUint32(\u0026o.done) == 0 { // 这步是判断是否已经完成初始化的关键 o.doSlow(f) } } func (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(\u0026o.done, 1) f() } } 官方对于sync.Once的实现是非常短小精悍的。其中atomic.LoadUint32(\u0026o.done) == 0是关键的一步，这里采用的是原子操作语句，保证了即使在并发场景下也是安全的，对数据的读写都是完整的。 当o.done的值为0时表示未进行初始化或正在初始化中，只有等于1时才表示初始化已经完成，即f()执行完成后由defer atomic.StoreUint32(\u0026o.done, 1)语句给o.done赋值1；也就是o.done作为是否完成初始化的标识，可能的值只有前面说的两个，为0时则加锁并尝试初始化流程，反之则视为已完成初始化直接跳过，这样就完美兼顾了效率与并发安全。 由此可见sync.Once内置的初始化完成标识判断远比if svc == nil 靠谱，因此像上面这样使用sync.Once实现单例模式是最推荐的方式。 ","date":"2022-10-01","objectID":"/112_glang-singleton/:3:0","tags":["Golang","设计模式"],"title":"Golang 单例模式与sync.Once","uri":"/112_glang-singleton/"},{"categories":["后端"],"content":"额外推荐 实则开发中用到的设计模式经常不止一种，越是复杂大型的项目就越需要使用更多合适的模式来优化代码。 下面要推荐的是RefactoringGuru。这是我所见过最好的设计模式教程，是国外创建的一个教程网站，有中文站点，图文并茂地介绍每一种模式的结构、关系和逻辑， 最重要的是示例代码方面囊括了常见的几种主流编程语言，是个适合多数程序员学习设计模式的好地方！ 下图是设计模式的目录页面（是不是很图文并茂呢）： ","date":"2022-10-01","objectID":"/112_glang-singleton/:4:0","tags":["Golang","设计模式"],"title":"Golang 单例模式与sync.Once","uri":"/112_glang-singleton/"},{"categories":["后端"],"content":"结语 以上为本人学习和实践的一些总结，如有错漏还请不吝赐教。 ","date":"2022-10-01","objectID":"/112_glang-singleton/:5:0","tags":["Golang","设计模式"],"title":"Golang 单例模式与sync.Once","uri":"/112_glang-singleton/"},{"categories":["后端"],"content":"参考 《Go程序设计语言》9.5 延迟初始化：sync.Once 网络版 Go 单例模式讲解和代码示例 ","date":"2022-10-01","objectID":"/112_glang-singleton/:6:0","tags":["Golang","设计模式"],"title":"Golang 单例模式与sync.Once","uri":"/112_glang-singleton/"},{"categories":["后端"],"content":"背景 GEN 是一个基于 GORM 的安全 ORM 框架, 由字节跳动无恒实验室与 GORM 作者联合研发，主要功能说白了就是帮助生成数据表对应的模型文件和更安全方便地执行SQL。 直接使用 GORM 与 GEN 工具的对比： 直接使用GORM 使用GEN 需手动创建与数据表各列一一对应的结构体 指定表名后自动读取并生成对应结构体 需手动实现具体的 go 代码查询逻辑 描述 SQL 查询逻辑即可，工具自动转换成安全稳定的代码 查询接口十分灵活，但不能保持查询的 SQL 不发生语法错误， 只能通过测试保证部分场景的正常运行 查询接口使用类型安全，编译可通过，查询逻辑即是正常合理的 需人工评经验保证业务不存在安全问题， 一旦出错往往在上线前才能发现，影响上线流程 提供的安全可靠的查询 API，开发时能用的就是安全的 ","date":"2022-09-16","objectID":"/111_gorm-gen/:1:0","tags":["Golang","GORM","GEN"],"title":"GEN 自动生成 GORM 模型结构体文件及使用示例","uri":"/111_gorm-gen/"},{"categories":["后端"],"content":"本文目标 GEN 提供的功能是强大而丰富的，本文相当一个上手指引只挑些常见操作进行示例说明： 表字段的整型类型无论大小和有无符号，结构体中统一使用 int64 （为了简化后续使用时的操作）。 个别结构体字段 json 序列化时由数字类型转成字符串类型，如：余额字段 balance 在表中是 DECIMAL 类型，结构体中是 int64，业务需要的 json 字段类型为字符串。 使用非默认字段名实现自动更新、创建时间戳和软删除。 模型关联 示例环境： go 1.18 gen v0.3.16 注意:当前GEN的最新版主版本是0, 也就是 API 在未来可能会有较大的变更, 使用时务必注意版本变更问题 MySQL 8.0 目标表有3个,分别是 user、address和 hobby，user与 address是一对多关系，如下所示: CREATETABLEIFNOTEXISTS`user`(`id`intunsignedNOTNULLAUTO_INCREMENTCOMMENT'ID',`name`varchar(20)CHARACTERSETutf8mb4COLLATEutf8mb4_general_ciNOTNULLDEFAULT''COMMENT'用户名',`age`tinyintunsignedNOTNULLDEFAULT'0'COMMENT'年龄',`balance`decimal(11,2)unsignedNOTNULLDEFAULT'0.00'COMMENT'余额',`updated_at`datetimeNOTNULLCOMMENT'更新时间',`created_at`datetimeNOTNULLCOMMENT'创建时间',`deleted_at`datetimeDEFAULTNULLCOMMENT'删除时间',PRIMARYKEY(`id`))ENGINE=InnoDBAUTO_INCREMENT=4DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_general_ci;CREATETABLEIFNOTEXISTS`address`(`id`intunsignedNOTNULLAUTO_INCREMENT,`uid`intunsignedNOTNULL,`province`varchar(20)CHARACTERSETutf8mb4COLLATEutf8mb4_general_ciNOTNULLDEFAULT'',`city`varchar(20)COLLATEutf8mb4_general_ciNOTNULLDEFAULT'',`update_time`intunsignedNOTNULL,`create_time`intunsignedNOTNULL,`delete_time`intunsignedNOTNULLDEFAULT'0',PRIMARYKEY(`id`)USINGBTREE,KEY`uid`(`uid`))ENGINE=InnoDBAUTO_INCREMENT=5DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_general_ciROW_FORMAT=DYNAMIC;CREATETABLEIFNOTEXISTS`hobby`(`id`intunsignedNOTNULLAUTO_INCREMENT,`name`varchar(20)CHARACTERSETutf8mb4COLLATEutf8mb4_general_ciNOTNULLDEFAULT'',`updated_at`intunsignedNOTNULL,`created_at`intunsignedNOTNULL,`deleted_at`intunsignedNOTNULLDEFAULT'0',PRIMARYKEY(`id`)USINGBTREE)ENGINE=InnoDBAUTO_INCREMENT=4DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_general_ciROW_FORMAT=DYNAMIC; ","date":"2022-09-16","objectID":"/111_gorm-gen/:2:0","tags":["Golang","GORM","GEN"],"title":"GEN 自动生成 GORM 模型结构体文件及使用示例","uri":"/111_gorm-gen/"},{"categories":["后端"],"content":"配置 GEN 并生成模型结构体 创建并初始化项目,再引入 GEN 包 mkdir gormgendemo \u0026\u0026 cd gormgendemo go mod init go get -u gorm.io/gen@v0.3.16 继续创建用于生成模型文件的 ./cmd/generate/main.go文件和用于执行 SQL 示例的 ./main.go文件，目录如下所示： ├── cmd │ └── generate │ └── main.go ├── go.mod ├── go.sum └── main.go ./cmd/generate/main.go代码： package main import ( \"fmt\" \"strings\" \"gorm.io/driver/mysql\" \"gorm.io/gen\" \"gorm.io/gen/field\" \"gorm.io/gorm\" ) const MySQLDSN = \"root:123456@(localhost:3306)/gormgendemo?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" func main() { // 连接数据库 db, err := gorm.Open(mysql.Open(MySQLDSN)) if err != nil { panic(fmt.Errorf(\"cannot establish db connection: %w\", err)) } // 生成实例 g := gen.NewGenerator(gen.Config{ // 相对执行`go run`时的路径, 会自动创建目录 OutPath: \"dal/query\", // WithDefaultQuery 生成默认查询结构体(作为全局变量使用), 即`Q`结构体和其字段(各表模型) // WithoutContext 生成没有context调用限制的代码供查询 // WithQueryInterface 生成interface形式的查询代码(可导出), 如`Where()`方法返回的就是一个可导出的接口类型 Mode: gen.WithDefaultQuery | gen.WithQueryInterface, // 表字段可为 null 值时, 对应结体字段使用指针类型 FieldNullable: true, // generate pointer when field is nullable // 表字段默认值与模型结构体字段零值不一致的字段, 在插入数据时需要赋值该字段值为零值的, 结构体字段须是指针类型才能成功, 即`FieldCoverable:true`配置下生成的结构体字段. // 因为在插入时遇到字段为零值的会被GORM赋予默认值. 如字段`age`表默认值为10, 即使你显式设置为0最后也会被GORM设为10提交. // 如果该字段没有上面提到的插入时赋零值的特殊需要, 则字段为非指针类型使用起来会比较方便. FieldCoverable: false, // generate pointer when field has default value, to fix problem zero value cannot be assign: https://gorm.io/docs/create.html#Default-Values // 模型结构体字段的数字类型的符号表示是否与表字段的一致, `false`指示都用有符号类型 FieldSignable: false, // detect integer field's unsigned type, adjust generated data type // 生成 gorm 标签的字段索引属性 FieldWithIndexTag: false, // generate with gorm index tag // 生成 gorm 标签的字段类型属性 FieldWithTypeTag: true, // generate with gorm column type tag }) // 设置目标 db g.UseDB(db) // 自定义字段的数据类型 // 统一数字类型为int64,兼容protobuf dataMap := map[string]func(detailType string) (dataType string){ \"tinyint\": func(detailType string) (dataType string) { return \"int64\" }, \"smallint\": func(detailType string) (dataType string) { return \"int64\" }, \"mediumint\": func(detailType string) (dataType string) { return \"int64\" }, \"bigint\": func(detailType string) (dataType string) { return \"int64\" }, \"int\": func(detailType string) (dataType string) { return \"int64\" }, } // 要先于`ApplyBasic`执行 g.WithDataTypeMap(dataMap) // 自定义模型结体字段的标签 // 将特定字段名的 json 标签加上`string`属性,即 MarshalJSON 时该字段由数字类型转成字符串类型 jsonField := gen.FieldJSONTagWithNS(func(columnName string) (tagContent string) { toStringField := `balance, ` if strings.Contains(toStringField, columnName) { return columnName + \",string\" } return columnName }) // 将非默认字段名的字段定义为自动时间戳和软删除字段; // 自动时间戳默认字段名为:`updated_at`、`created_at, 表字段数据类型为: INT 或 DATETIME // 软删除默认字段名为:`deleted_at`, 表字段数据类型为: DATETIME autoUpdateTimeField := gen.FieldGORMTag(\"update_time\", \"column:update_time;type:int unsigned;autoUpdateTime\") autoCreateTimeField := gen.FieldGORMTag(\"create_time\", \"column:create_time;type:int unsigned;autoCreateTime\") softDeleteField := gen.FieldType(\"delete_time\", \"soft_delete.DeletedAt\") // 模型自定义选项组 fieldOpts := []gen.ModelOpt{jsonField, autoCreateTimeField, autoUpdateTimeField, softDeleteField} // 创建模型的结构体,生成文件在 model 目录; 先创建的结果会被后面创建的覆盖 // 这里创建个别模型仅仅是为了拿到`*generate.QueryStructMeta`类型对象用于后面的模型关联操作中 Address := g.GenerateModel(\"address\") // 创建全部模型文件, 并覆盖前面创建的同名模型 allModel := g.GenerateAllTable(fieldOpts...) // 创建有关联关系的模型文件 User := g.GenerateModel(\"user\", append( fieldOpts, // user 一对多 address 关联, 外键`uid`在 address 表中 gen.FieldRelate(field.HasMany, \"Address\", Address, \u0026field.RelateConfig{GORMTag: \"foreignKey:UID\"}), )..., ) Address = g.GenerateModel(\"address\", append( fieldOpts, gen.FieldRelate(field.BelongsTo, \"User\", User, \u0026field.RelateConfig{GORMTag: \"foreignKey:UID\"}), )..., ) // 创建模型的方法,生成文件在 query 目录; 先创建结果不会被后创建的覆盖 g.ApplyBasic(User, Address) g.ApplyBasic(allModel...) g.Execute() } 执行生成程序: go mod tidy go run ./cmd/generate/main.go 结果目录: . ├── cmd │ └── generate │ └── main.go ├── dal │ ├── model │ │ ├── address.gen.go │ │ ├── hobby.gen.go │ │ └── user.gen.","date":"2022-09-16","objectID":"/111_gorm-gen/:3:0","tags":["Golang","GORM","GEN"],"title":"GEN 自动生成 GORM 模型结构体文件及使用示例","uri":"/111_gorm-gen/"},{"categories":["后端"],"content":"使用 GEN 进行数据库操作 ./main.go代码： package main import ( \"context\" \"fmt\" \"log\" \"gormgendemo/dal/model\" \"gormgendemo/dal/query\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) const MySQLDSN = \"root:123456@(localhost:3306)/gormgendemo?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" func main() { // 连接数据库 db, err := gorm.Open(mysql.Open(MySQLDSN)) if err != nil { panic(fmt.Errorf(\"cannot establish db connection: %w\", err)) } query.SetDefault(db) q := query.Q ctx := context.Background() //qc := q.WithContext(ctx) // 增 insert(ctx, q) // 删 del(ctx, q) // 改 update(ctx, q) // 查 find(ctx, q) fmt.Println(\"Done!\") } func insert(ctx context.Context, q *query.Query) { qc := q.WithContext(ctx) // 插入数据 users := []*model.User{ { Name: \"张三\", Age: 30, Address: []model.Address{ {Province: \"广东\", City: \"广州\"}, {Province: \"广东\", City: \"深圳\"}, }, }, { Name: \"李四\", Age: 40, Address: []model.Address{ {Province: \"广东\", City: \"广州\"}, {Province: \"广东\", City: \"深圳\"}, }, }, { Name: \"王五\", Age: 50, }, } hobby := []*model.Hobby{ {Name: \"看电影\"}, {Name: \"看书\"}, {Name: \"跑步\"}, } err := qc.User.Create(users...) if err != nil { log.Fatal(err) } err = qc.Hobby.Create(hobby...) if err != nil { log.Fatal(err) } } func del(ctx context.Context, q *query.Query) { qc := q.WithContext(ctx) qc.User.Where(q.User.Name.Eq(\"张三\")).Delete() // 软删 qc.Address.Where(q.Address.City.Eq(\"深圳\")).Delete() // 软删 qc.Hobby.Where(q.Hobby.Name.Eq(\"看电影\")).Delete() // 非软删 } func update(ctx context.Context, q *query.Query) { qc := q.WithContext(ctx) qc.User.Where(q.User.Name.Eq(\"李四\")).UpdateSimple(q.User.Age.Add(1)) } func find(ctx context.Context, q *query.Query) { qc := q.WithContext(ctx) // First、Take、Last 方法, 如果没有找到记录则返回错误 ErrRecordNotFound。 _, err := qc.User.Preload(q.User.Address).Where(q.User.Name.Eq(\"张三\")).First() if err != nil { fmt.Printf(\"%+v \\n\", err) //record not found } user, err := qc.User.Preload(q.User.Address).Where(q.User.Name.Eq(\"李四\")).First() if err == nil { fmt.Printf(\"%+v \\n\", *user) //{ID:2 Name:李四 Age:41 Balance:0 UpdatedAt:2022-09-16 15:13:39 +0800 CST CreatedAt:2022-09-16 15:13:39 +0800 CST //DeletedAt:{Time:0001-01-01 00:00:00 +0000 UTC Valid:false} //Address:[{ID:3 UID:2rovince:广东 City:广州 UpdateTime:1663312418 CreateTime:1663312418 DeleteTime:0 //User:{ID:0 Name: Age:0 Balance:0 UpdatedAt:0001-01-01 00:00:00 +0000 UTC CreatedAt:0001-01-01 00:00:00 +0000 UTC //CreatedAt:{Time:0001-01-01 00:00:00 +0000 UTC Valid:false} Address:[]}}]} } addr, err := qc.Address.Preload(q.Address.User).Offset(1).First() if err == nil { fmt.Printf(\"%+v \\n\", *addr) //{ID:3 UID:2 Province:广东 City:广州 UpdateTime:1663312418 CreateTime:1663312418 DeleteTime:0 //User:{ID:2 Name:李四 Age:41 Balance:0 UpdatedAt:2022-09-16 15:13:39 +0800 CST CreatedAt:2022-09-16 39 +0800 CST //DeletedAt:{Time:0001-01-01 00:00:00 +0000 UTC Valid:false} Address:[]}} } _, err = qc.Hobby.Where(q.Hobby.Name.Eq(\"看电影\")).First() if err != nil { fmt.Printf(\"%+v \\n\", err) //record not found } hb, err := qc.Hobby.Where(q.Hobby.Name.Eq(\"看书\")).First() if err == nil { fmt.Printf(\"%+v \\n\", *hb) //{ID:2 Name:看书 UpdatedAt:1663312418 CreatedAt:1663312418 DeletedAt:0} } } 执行使用程序可以看到效果 go run main.go ","date":"2022-09-16","objectID":"/111_gorm-gen/:4:0","tags":["Golang","GORM","GEN"],"title":"GEN 自动生成 GORM 模型结构体文件及使用示例","uri":"/111_gorm-gen/"},{"categories":["后端"],"content":"结语 示例的相关代码已上传github仓库，有需要的可以自取。如果文章中有什么错漏或改善的地方也欢迎给我留言交流。 上面示例仅作抛砖引玉之用，更多使用方法还得参考官方文档和源码。 最后在这里对 GORM 和 GEN 的开发者们给我们带来了这么好用的工具表示感谢！ ","date":"2022-09-16","objectID":"/111_gorm-gen/:5:0","tags":["Golang","GORM","GEN"],"title":"GEN 自动生成 GORM 模型结构体文件及使用示例","uri":"/111_gorm-gen/"},{"categories":["后端"],"content":"参考 GORM/GEN中文文档 无恒实验室联合GORM推出安全好用的ORM框架-GEN ","date":"2022-09-16","objectID":"/111_gorm-gen/:6:0","tags":["Golang","GORM","GEN"],"title":"GEN 自动生成 GORM 模型结构体文件及使用示例","uri":"/111_gorm-gen/"},{"categories":["后端"],"content":"Elasticsearch的标准版本及以上是支持设置同义词功能的, 其实也就是除了OSS(开源)版以外其它的都支持. ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:0:0","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"环境说明 Elasticsearch 7.6.x 与ES相匹配的IK分词插件 示例中会分别使用到shell命令和Kibana, 以$开头的代表是shell命令, 否则表示Kibana的console命令 ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:1:0","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"操作 同义词可以使用 synonym 参数来内嵌指定，或者必须 存在于集群每一个节点上的同义词文件中。 同义词文件路径由 synonyms_path 参数指定，应绝对或相对于 Elasticsearch config 目录。 下面以同义词的两种设置方式来介绍: ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:2:0","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"同义词文件方式 设置同义词文件 # 进入Elasticsearch目录执行,生成文件 $ echo '\"iPhone,苹果手机 =\u003e iPhone,苹果手机\", \"2233,22娘,33娘 =\u003e bilibili,B站\"' \u003e config/analysis/synonyms.txt 创建索引 PUT /goods2 { \"settings\": { \"analysis\": { \"filter\": { \"my_synonym_filter\": { \"type\": \"synonym\", \"updateable\": true, \"synonyms_path\": \"analysis/synonyms.txt\" } }, \"analyzer\": { \"my_synonyms_analyzer\": { \"tokenizer\": \"ik_smart\", \"filter\": [ \"my_synonym_filter\" ] } } } }, \"mappings\": { \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\", \"search_analyzer\": \"my_synonyms_analyzer\" } } } } my_synonym_filter是自定义的词汇过滤器, my_synonyms_analyzer是自定义的分析器, 可以看出后者是包含并引用了前者的. 在本索引中自定义的词汇过虑器和分析器也只能在当前索引中使用. updateable指示能否动态更新, 必须为true才能动态更新同义词 synonyms_path指示同义词文件的位置 analysis.analyzer.tokenizer指示在这个分析器里用ik_smart的分词器, 在这个索引中的分析链是原始文本 =\u003e 分词器 =\u003e 词汇过滤器, 即原始文本先经过分词的结果再用来给词汇过滤器处理(在这个索引的作用是同义词). mappings.properties.title.search_analyzer指示title字段在查询时使用my_synonyms_analyzer分析器, 同理mappings.properties.title.analyzer指示其在索引时使用的分析器. 查看分析结果 第一行分词的效果 # 字母大小写没有影响 GET goods2/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"iphone\" } GET goods2/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"苹果手机\" } 上面两条语句的结果是一样的 { \"tokens\" : [ { \"token\" : \"iphone\", \"start_offset\" : 0, \"end_offset\" : 6, \"type\" : \"ENGLISH\", \"position\" : 0 }, { \"token\" : \"苹果\", \"start_offset\" : 0, \"end_offset\" : 6, \"type\" : \"SYNONYM\", \"position\" : 0 }, { \"token\" : \"手机\", \"start_offset\" : 0, \"end_offset\" : 6, \"type\" : \"SYNONYM\", \"position\" : 1 } ] } 第二行分词的效果 GET goods2/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"2233\" } GET goods2/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"22娘\" } 结果 { \"tokens\" : [ { \"token\" : \"bilibili\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 0 }, { \"token\" : \"b\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 0 }, { \"token\" : \"站\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 1 } ] } 变更同义词并更新索引 # 进入Elasticsearch目录执行,生成文件 # `iPhone,苹果手机 =\u003e iPhone,苹果手机`与`iPhone,苹果手机`的效果是一样的 # 内容中的双引号`\"`和行末的逗号`,`不是必须的(没有的话须要有换行符), 这里只是为了和和内嵌式的保持一致才这么写的 $ echo '\"iPhone,苹果手机\", \"2233,22娘,33娘 =\u003e bilibili,B站,二次元\"' \u003e config/analysis/synonyms.txt # 使新的同义词生效 POST /goods2/_reload_search_analyzers 变更同义词后的第二行分词的效果 GET goods2/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"2233\" } 结果 { \"tokens\" : [ { \"token\" : \"bilibili\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 0 }, { \"token\" : \"b\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 0 }, { \"token\" : \"二次元\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 0 }, { \"token\" : \"站\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"SYNONYM\", \"position\" : 1 } ] } ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:2:1","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"内嵌方式 创建索引 同义词配置就在synonyms属性里 PUT /goods3 { \"settings\": { \"analysis\": { \"filter\": { \"my_synonym_filter\": { \"type\": \"synonym\", \"synonyms\": [ \"iPhone,苹果手机 =\u003e iPhone,苹果手机\", \"2233,22娘,33娘 =\u003e bilibili,B站\" ] } }, \"analyzer\": { \"my_synonyms_analyzer\": { \"tokenizer\": \"ik_smart\", \"filter\": [ \"my_synonym_filter\" ] } } } }, \"mappings\": { \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\", \"search_analyzer\": \"my_synonyms_analyzer\" } } } } 查看分析结果 下面的结果跟同义词文件方式的是一样的 GET goods3/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"iphone\" } GET goods3/_analyze { \"analyzer\": \"my_synonyms_analyzer\", \"text\": \"2233\" } 变更同义词并更新索引 # 须要先关闭索引才能变更设置 POST /goods3/_close PUT /goods3/_settings/ { \"analysis\": { \"filter\": { \"my_synonym_filter\": { \"type\": \"synonym\", \"synonyms\": [ \"iPhone,苹果手机\", \"2233,22娘,33娘 =\u003e bilibili,B站,二次元\" ] } } } } # 重新开启索引 POST /goods3/_open ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:2:2","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"查询实践 以索引goods2为例 # 插入一条数据 POST /goods2/_doc/1 { \"title\":\"bilibili是个好平台\" } # 通过`2233`关键词查找 GET /goods2/_search { \"query\": { \"match\": { \"title\": \"2233\" } } } 结果 { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : { \"value\" : 1, \"relation\" : \"eq\" }, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"goods2\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"title\" : \"bilibili是个好平台\" } } ] } } ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:2:3","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"总结 在Elasticsearch中设置同义词有内嵌式和同义词文件式两种 同义词文件式可以在不关闭索引的情况下动态更新同义词 ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:3:0","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"参考资料 Elasticsearch Reference 7.6 重载分析器API Elasticsearch: 权威指南 Elastic Stack 各版本的区别 ","date":"2020-06-10","objectID":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/:4:0","tags":["Elasticsearch"],"title":"Elasticsearch中文同义词","uri":"/106_es_%E5%90%8C%E4%B9%89%E8%AF%8D/"},{"categories":["后端"],"content":"说明 本文是学习Learnku的 电商课程 Elasticsearch(下面将称之为:ES)部分的学习笔记,主要介绍常见的电商商品数据如何存入ES和查询出来.ES作为搜索引擎,相比数据库的SQL搜索语句可以实现更多丰富的筛选条件. 常见的使用方法是:先按用户的搜索条件从ES中查询出关键信息(如id),然后直接列表返回给用户,或是根据ES结果作为SQL条件再从数据库中查询. 本文仅以DSL作为查询示例,不会涉及在各个编程语言中的实现代码. ","date":"2020-04-15","objectID":"/105_es_goods_search/:1:0","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"操作环境 Elasticsearch 7.6.x 与ES相匹配的IK分词插件 ","date":"2020-04-15","objectID":"/105_es_goods_search/:1:1","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"商品信息数据结构 下面的SQL是创建商品相关表和插入数据的语句, 本文主要着重介绍的是在这种数据结构下ES的索引结构和查询写法,所以这些SQL不实际执行也不会影响到后面说到的DSL操作的. #商品信息主表CREATETABLE`products`(`id`bigintunsignedNOTNULLAUTO_INCREMENT,`type`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULLDEFAULT'normal',`category_id`bigintunsignedDEFAULTNULL,`title`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,`long_title`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,`description`textCOLLATEutf8mb4_unicode_ciNOTNULL,`image`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,`on_sale`tinyint(1)NOTNULLDEFAULT'1',`rating`double(8,2)NOTNULLDEFAULT'5.00',`sold_count`intunsignedNOTNULLDEFAULT'0',`review_count`intunsignedNOTNULLDEFAULT'0',`price`decimal(10,2)NOTNULL,`created_at`timestampNULLDEFAULTNULL,`updated_at`timestampNULLDEFAULTNULL,PRIMARYKEY(`id`),KEY`products_category_id_foreign`(`category_id`),KEY`products_type_index`(`type`))ENGINE=InnoDBAUTO_INCREMENT=100DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci#端口的sku表,每个库存单位占一条,如:同款手机的不同版本就各算作一个库存单位,对应的价格可能也不一样的,主要用来确定货单价和库存的#与主表关联CREATETABLE`product_skus`(`id`bigintunsignedNOTNULLAUTO_INCREMENT,`title`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,`description`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,`price`decimal(10,2)NOTNULL,`stock`intunsignedNOTNULL,`product_id`bigintunsignedNOTNULL,`created_at`timestampNULLDEFAULTNULL,`updated_at`timestampNULLDEFAULTNULL,PRIMARYKEY(`id`),KEY`product_skus_product_id_foreign`(`product_id`),CONSTRAINT`product_skus_product_id_foreign`FOREIGNKEY(`product_id`)REFERENCES`products`(`id`)ONDELETECASCADE)ENGINE=InnoDBAUTO_INCREMENT=295DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci#商品的详细属性,每个属性占一条,不同商品之间允许存在同名的属性,如:A手机的`内存`属性值为`8G`,主要用来展示属性和筛选商品的#与主表关联CREATETABLE`product_properties`(`id`bigintunsignedNOTNULLAUTO_INCREMENT,`product_id`bigintunsignedNOTNULL,`name`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,`value`varchar(255)COLLATEutf8mb4_unicode_ciNOTNULL,PRIMARYKEY(`id`),KEY`product_properties_product_id_foreign`(`product_id`),CONSTRAINT`product_properties_product_id_foreign`FOREIGNKEY(`product_id`)REFERENCES`products`(`id`)ONDELETECASCADE)ENGINE=InnoDBAUTO_INCREMENT=27DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci 对应的数据记录 INSERTINTO`products`(`id`,`type`,`category_id`,`title`,`long_title`,`description`,`image`,`on_sale`,`rating`,`sold_count`,`review_count`,`price`,`created_at`,`updated_at`)VALUES(91,'normal',13,'Kingston/金士顿 HX424C15FB/8','金士顿 骇客神条 ddr4 2400 8g 台式机 电脑 四代内存条 吃鸡内存','\u003cp\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i3/704392951/TB25akyqsuYBuNkSmRyXXcA3pXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i1/704392951/TB288x6y25TBuNjSspmXXaDRVXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i1/704392951/TB2ck46y7CWBuNjy0FaXXXUlXXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i2/704392951/TB2_OV3y1uSBuNjSsziXXbq8pXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i3/704392951/TB2F9KZiP7nBKNjSZLeXXbxCFXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i4/704392951/TB2XQ06y7CWBuNjy0FaXXXUlXXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i2/704392951/TB20Tl7y4SYBuNjSspjXXX73VXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i2/704392951/TB2QygAqDdYBeNkSmLyXXXfnVXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i3/704392951/TB2C6S5qyCYBuNkHFCcXXcHtVXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i2/704392951/TB2J_pByYGYBuNjy0FoXXciBFXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i2/704392951/TB2520Ny29TBuNjy1zbXXXpepXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i4/704392951/TB2ozkLyFmWBuNjSspdXXbugXXa_!!704392951.jpg\\\" /\u003e\u003cimg src=\\\"https://img.alicdn.com/imgextra/i4/704392951/TB2S9IFiOAnBKNjSZFvXXaTKXXa_!!704392951.jpg\\\" /\u003e\u003c/p\u003e\u003cp\u003e\u003cimg alt=\\\"\\\" src=\\\"https://gdp.alicdn.com/imgextra/i4/704392951/TB2KpHwfviSBuNkSnhJXXbDcpXa_!!704392951.jpg\\\" /\u003e\u003c/p\u003e','https://img.alicdn.com/bao/uploaded/i2/TB1iqkaLVXXXXagXXXXObG1FpXX_091208.jpg_b.jpg',1,5.00,0,0,'399.00','202","date":"2020-04-15","objectID":"/105_es_goods_search/:2:0","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"ES操作 下面是重点 ","date":"2020-04-15","objectID":"/105_es_goods_search/:3:0","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"存入 创建索引 # 创建索引`products`,`pretty`参数表示返回的结果以美化的格式输出 curl -XPUT http://localhost:9200/products?pretty # 设置索引的属性,`skus`后的一个嵌套属性`properties`并不是关键字,是自定义的名称,指代`product_properties`表的数据 curl -XPUT http://localhost:9200/products/_mapping/?pretty -H 'Content-Type: application/json' -d '{ \"properties\": { \"type\": { \"type\": \"keyword\" } , \"title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\" }, \"long_title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\" }, \"category_id\": { \"type\": \"integer\" }, \"category\": { \"type\": \"keyword\" }, \"category_path\": { \"type\": \"keyword\" }, \"description\": { \"type\": \"text\", \"analyzer\": \"ik_smart\" }, \"price\": { \"type\": \"scaled_float\", \"scaling_factor\": 100 }, \"on_sale\": { \"type\": \"boolean\" }, \"rating\": { \"type\": \"float\" }, \"sold_count\": { \"type\": \"integer\" }, \"review_count\": { \"type\": \"integer\" }, \"skus\": { \"type\": \"nested\", \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\", \"copy_to\": \"skus_title\" }, \"description\": { \"type\": \"text\", \"analyzer\": \"ik_smart\", \"copy_to\": \"skus_description\" }, \"price\": { \"type\": \"scaled_float\", \"scaling_factor\": 100 } } }, \"properties\": { \"type\": \"nested\", \"properties\": { \"name\": { \"type\": \"keyword\" }, \"value\": { \"type\": \"keyword\", \"copy_to\": \"properties_value\" }, \"search_value\": { \"type\": \"keyword\"} } } } }' \"analyzer\": \"ik_smart\" 代表这个字段需要使用 IK 中文分词器分词，在前面的章节也介绍过了。 还有有一些字段的类型是 keyword，这是字符串类型的一种，这种类型是告诉 Elasticsearch 不需要对这个字段做分词，通常用于邮箱、标签、属性等字段。 scaled_float 代表一个小数位固定的浮点型字段，与 Mysql 的 decimal 类型类似，后面的 scaling_factor 用来指定小数位精度，100 就代表精确到小数点后两位。 skus 和 properties 的字段类型是 nested，代表这个字段是一个复杂对象，由下一级的 properties 字段定义这个对象的字段。有同学可能会问，我们的『商品 SKU』和『商品属性』明明是对象数组，为什么这里可以定义成对象？这是 Elasticsearch 的另外一个特性，每个字段都可以保存多个值，这也是 Elasticsearch 的类型没有数组的原因，因为不需要，每个字段都可以是数组。 注意看 skus.title 字段的定义里加入了 copy_to 参数，值是 skus_title，Elasticsearch 就会把这个字段值复制到 skus_title 字段里，这样就可以在 multi_match 的 fields 里通过 skus_title 来匹配。skus.description 和 properties.name 同理。 请确保 Elasticsearch 返回了 \"acknowledged\" : true，否则就要检查提交的内容是否有问题。 导入数据到ES shell命令连接ES按照索引的数据结构导入3条数据 category curl -XPUT http://localhost:9200/products/_doc/91?pretty -H'Content-Type: application/json' -d'{\"id\":91,\"type\":\"normal\",\"category_id\":13,\"title\":\"Kingston\\/金士顿 HX424C15FB\\/8\",\"long_title\":\"金士顿 骇客神条 ddr4 2400 8g 台式机 电脑 四代内存条 吃鸡内存\",\"on_sale\":true,\"rating\":5,\"sold_count\":0,\"review_count\":0,\"price\":\"399.00\",\"category\":[\"电脑配件\",\"内存\"],\"category_path\":\"-10-\",\"description\":\"\",\"skus\":[{\"title\":\"8GB 黑色\",\"description\":\"8GB 2400 DDR4 黑色\",\"price\":\"549.00\"},{\"title\":\"8GB 绿色\",\"description\":\"8GB 2400 DDR4 绿色\",\"price\":\"529.00\"},{\"title\":\"16GB\",\"description\":\"2400 16GB\",\"price\":\"1299.00\"},{\"title\":\"4GB\",\"description\":\"2400 4GB\",\"price\":\"399.00\"}],\"properties\":[{\"name\":\"品牌名称\",\"value\":\"金士顿\",\"search_value\":\"品牌名称:金士顿\"},{\"name\":\"内存容量\",\"value\":\"8GB\",\"search_value\":\"内存容量:8GB\"},{\"name\":\"传输类型\",\"value\":\"DDR4\",\"search_value\":\"传输类型:DDR4\"},{\"name\":\"内存容量\",\"value\":\"4GB\",\"search_value\":\"内存容量:4GB\"},{\"name\":\"内存容量\",\"value\":\"16GB\",\"search_value\":\"内存容量:16GB\"}]}' curl -XPUT http://localhost:9200/products/_doc/92?pretty -H'Content-Type: application/json' -d'{\"id\":92,\"type\":\"normal\",\"category_id\":13,\"title\":\"AData\\/威刚 8G DDR4 2400 (XPG 单条） \",\"long_title\":\"ADATA\\/威刚 8G 16G 3200 3000 2666 2400游戏台式机内存条DDR4套条\",\"on_sale\":true,\"rating\":5,\"sold_count\":0,\"review_count\":0,\"price\":\"489.00\",\"category\":[\"电脑配件\",\"内存\"],\"category_path\":\"-10-\",\"description\":\"\",\"skus\":[{\"title\":\"8GB DDR4 2400\",\"description\":\"8GB DDR4 2400 XPG单条\",\"price\":\"489.00\"},{\"title\":\"4GB 万紫千红 DDR4 2133\",\"description\":\"4GB 万紫千红 DDR4 2133\",\"price\":\"489.00\"}],\"properties\":[{\"name\":\"品牌名称\",\"value\":\"威刚\",\"search_value\":\"品牌名称:威刚\"},{\"name\":\"传输类型\",\"value\":\"DDR4\",\"search_value\":\"传输类型:DDR4\"},{\"name\":\"内存容量\",\"value\":\"4GB\",\"search_value\":\"内存容量:4GB\"},{\"name\":\"内存容量\",\"value\":\"8GB\",\"search_value\":\"内存容量:8GB\"}]}' curl -XPUT http://localhost:9200/products/_doc/93?pretty -H'Content-Type: application/json' -d'{\"id\":93,\"type\":\"normal\",\"category_id\":13,\"title\":\"Kingston\\/金士顿 金士顿DDR3 1600 8GB\",\"long_title\":\"Kingston\\/金士顿 DDR3 1600 8G 台式机电脑 三代 内存条 兼容1333\",\"on_sale\":true,\"rat","date":"2020-04-15","objectID":"/105_es_goods_search/:3:1","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"查询 # 直接用curl进行查询请求 curl -XGET http://localhost:9200/products/_search/?pretty -H 'Content-Type: application/json' -d '{ \"query\": { \"bool\": { \"filter\": [ { \"term\": { \"on_sale\": true } } ], \"must\": [ { \"multi_match\": { \"query\": \"金士顿\", \"type\": \"best_fields\", \"fields\": [ \"title^3\", \"long_title^2\", \"category^2\", \"description\", \"skus_title\", \"skus_description\", \"properties_value\" ] } } ] } }, \"aggs\": { \"properties_count\": { \"nested\": { \"path\": \"properties\" }, \"aggs\": { \"properties_name\": { \"terms\": { \"field\": \"properties.name\" }, \"aggs\": { \"properties_value\": { \"terms\": { \"field\": \"properties.value\" } } } } } } } }' 对上面DSL语句的一些解释: 以金士顿作为关键字在多个字段中进行查询,title^3表示提升从title字段查询出来的结果的权重 properties_count是自定义的聚合结果名称,同理后面的properties_*亦然 properties_count聚合的作用是相当于在查询出来的结果中,将嵌套属性properties全部查询出来 properties_name是在上一层的基础上按properties.name即属性名分组 properties_value同理,在上一层的基础上按属性值分组 查询结果: { \"took\" : 3, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : { \"value\" : 2, \"relation\" : \"eq\" }, \"max_score\" : 1.9678952, \"hits\" : [ { \"_index\" : \"products\", \"_type\" : \"_doc\", \"_id\" : \"93\", \"_score\" : 1.9678952, \"_source\" : { \"id\" : 93, \"type\" : \"normal\", \"category_id\" : 13, \"title\" : \"Kingston/金士顿 金士顿DDR3 1600 8GB\", \"long_title\" : \"Kingston/金士顿 DDR3 1600 8G 台式机电脑 三代 内存条 兼容1333\", \"on_sale\" : true, \"rating\" : 5, \"sold_count\" : 0, \"review_count\" : 0, \"price\" : \"239.00\", \"category\" : [ \"电脑配件\", \"内存\" ], \"category_path\" : \"-10-\", \"description\" : \"\", \"skus\" : [ { \"title\" : \"DDR3 1600 8G\", \"description\" : \"DDR3 1600 8G\", \"price\" : \"439.00\" }, { \"title\" : \"DDR3 1600 4G\", \"description\" : \"DDR3 1600 4G\", \"price\" : \"239.00\" }, { \"title\" : \"DDR3 1333 4G\", \"description\" : \"DDR3 1333 4G\", \"price\" : \"259.00\" } ], \"properties\" : [ { \"name\" : \"品牌名称\", \"value\" : \"金士顿\", \"search_value\" : \"品牌名称:金士顿\" }, { \"name\" : \"传输类型\", \"value\" : \"DDR3\", \"search_value\" : \"传输类型:DDR3\" }, { \"name\" : \"内存容量\", \"value\" : \"4GB\", \"search_value\" : \"内存容量:4GB\" }, { \"name\" : \"内存容量\", \"value\" : \"8GB\", \"search_value\" : \"内存容量:8GB\" } ] } }, { \"_index\" : \"products\", \"_type\" : \"_doc\", \"_id\" : \"91\", \"_score\" : 1.6602381, \"_source\" : { \"id\" : 91, \"type\" : \"normal\", \"category_id\" : 13, \"title\" : \"Kingston/金士顿 HX424C15FB/8\", \"long_title\" : \"金士顿 骇客神条 ddr4 2400 8g 台式机 电脑 四代内存条 吃鸡内存\", \"on_sale\" : true, \"rating\" : 5, \"sold_count\" : 0, \"review_count\" : 0, \"price\" : \"399.00\", \"category\" : [ \"电脑配件\", \"内存\" ], \"category_path\" : \"-10-\", \"description\" : \"\", \"skus\" : [ { \"title\" : \"8GB 黑色\", \"description\" : \"8GB 2400 DDR4 黑色\", \"price\" : \"549.00\" }, { \"title\" : \"8GB 绿色\", \"description\" : \"8GB 2400 DDR4 绿色\", \"price\" : \"529.00\" }, { \"title\" : \"16GB\", \"description\" : \"2400 16GB\", \"price\" : \"1299.00\" }, { \"title\" : \"4GB\", \"description\" : \"2400 4GB\", \"price\" : \"399.00\" } ], \"properties\" : [ { \"name\" : \"品牌名称\", \"value\" : \"金士顿\", \"search_value\" : \"品牌名称:金士顿\" }, { \"name\" : \"内存容量\", \"value\" : \"8GB\", \"search_value\" : \"内存容量:8GB\" }, { \"name\" : \"传输类型\", \"value\" : \"DDR4\", \"search_value\" : \"传输类型:DDR4\" }, { \"name\" : \"内存容量\", \"value\" : \"4GB\", \"search_value\" : \"内存容量:4GB\" }, { \"name\" : \"内存容量\", \"value\" : \"16GB\", \"search_value\" : \"内存容量:16GB\" } ] } } ] }, \"aggregations\" : { \"properties_count\" : { \"doc_count\" : 9, \"properties_name\" : { \"doc_count_error_upper_bound\" : 0, \"sum_other_doc_count\" : 0, \"buckets\" : [ { \"key\" : \"内存容量\", \"doc_count\" : 5, \"properties_value\" : { \"doc_count_error_upper_bound\" : 0, \"sum_other_doc_count\" : 0, \"buckets\" : [ { \"key\" : \"4GB\", \"doc_count\" : 2 }, { \"key\" : \"8GB\", \"doc_count\" : 2 }, { \"key\" : \"16GB\", \"doc_count\" : 1 } ] } }, { \"key\" : \"传输类型\", \"doc_count\" : 2, \"properties_value\" : { \"doc_count_error_upper_bound\" : 0, \"sum_other_doc_count\" : 0, \"buckets\" : [ { \"key\" : \"DDR3\", \"doc_count\" : 1 }, { \"key\" : \"DDR4\", \"doc_count\" : 1 } ] } }, { \"key\" : \"品牌名称\", \"doc_count\" : 2, \"properties_value\" : { \"doc_count_error_upper_bound\" : 0, \"sum_other_doc_count\" : 0, \"buckets\" : [ { \"key\" : \"金士顿\", \"doc_count\" : 2 } ] } } ] } } } } ","date":"2020-04-15","objectID":"/105_es_goods_search/:3:2","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"参考资料 《L06 Laravel 教程 - 电商进阶 ( Laravel 6.x )》 ","date":"2020-04-15","objectID":"/105_es_goods_search/:4:0","tags":["Elasticsearch","PHP"],"title":"电商商品信息Elasticsearch索引结构与查询示例","uri":"/105_es_goods_search/"},{"categories":["后端"],"content":"操作环境 下面的程序和运行环境都是使用Laradock部署的 Elasticsearch 7.6.1 Kibana 7.6.1 PHP 7.2 elasticsearch/elasticsearch ~7.6.0 ","date":"2020-04-02","objectID":"/104_es_base/:1:0","tags":["Elasticsearch","Kibana","PHP"],"title":"Elasticsearch DSL的PHP写法示例","uri":"/104_es_base/"},{"categories":["后端"],"content":"示例 ","date":"2020-04-02","objectID":"/104_es_base/:2:0","tags":["Elasticsearch","Kibana","PHP"],"title":"Elasticsearch DSL的PHP写法示例","uri":"/104_es_base/"},{"categories":["后端"],"content":"导入数据 所有的DSL语句都在Kibana的Dev Tools工具中执行. # 导入的数据取材自参考资料二 # 书籍文档信息的集合（有以下字段：title（标题）, authors（作者）, summary（摘要）, publish_date（发布日期）和 num_reviews（浏览数） POST /bookdb_index/_bulk {\"index\":{\"_id\":1}} {\"title\":\"Elasticsearch: The Definitive Guide\",\"authors\":[\"clinton gormley\",\"zachary tong\"],\"summary\":\"A distibuted real-time search and analytics engine\",\"publish_date\":\"2015-02-07\",\"num_reviews\":20,\"publisher\":\"oreilly\"} {\"index\":{\"_id\":2}} {\"title\":\"Taming Text: How to Find, Organize, and Manipulate It\",\"authors\":[\"grant ingersoll\",\"thomas morton\",\"drew farris\"],\"summary\":\"organize text using approaches such as full-text search, proper name recognition, clustering, tagging, information extraction, and summarization\",\"publish_date\":\"2013-01-24\",\"num_reviews\":12,\"publisher\":\"manning\"} {\"index\":{\"_id\":3}} {\"title\":\"Elasticsearch in Action\",\"authors\":[\"radu gheorge\",\"matthew lee hinman\",\"roy russo\"],\"summary\":\"build scalable search applications using Elasticsearch without having to do complex low-level programming or understand advanced data science algorithms\",\"publish_date\":\"2015-12-03\",\"num_reviews\":18,\"publisher\":\"manning\"} {\"index\":{\"_id\":4}} {\"title\":\"Solr in Action\",\"authors\":[\"trey grainger\",\"timothy potter\"],\"summary\":\"Comprehensive guide to implementing a scalable search engine using Apache Solr\",\"publish_date\":\"2014-04-05\",\"num_reviews\":23,\"publisher\":\"manning\"} ","date":"2020-04-02","objectID":"/104_es_base/:2:1","tags":["Elasticsearch","Kibana","PHP"],"title":"Elasticsearch DSL的PHP写法示例","uri":"/104_es_base/"},{"categories":["后端"],"content":"DSL 代码 # 下面这些筛选条件完全是为了举例写法才写这么多的... GET /bookdb_index/_search { \"query\": { \"bool\": { \"must\": [ { \"multi_match\": { \"query\": \"elasticsearch guide\", \"fields\": [] } }, { \"match_phrase_prefix\": { \"title\": { \"query\": \"elastic\", \"slop\": 3, \"max_expansions\": 10 } } }, { \"wildcard\": { \"title\": \"elastic*\" } }, { \"regexp\": { \"title\": \"elastic.*ch\" } }, { \"range\": { \"num_reviews\": { \"from\": 10, \"to\": 20, \"include_lower\": true, \"include_upper\": true } } } ], \"must_not\": [ { \"terms\": { \"publish_date\": [ \"2015-12-04\" ] } } ], \"should\": [ { \"match\": { \"publisher\": \"manning\" } } ], \"filter\": [ { \"exists\": { \"field\": \"authors\" } }, { \"range\": { \"num_reviews\": { \"gte\": 12, \"lt\": 30 } } } ] } }, \"highlight\": { \"fields\": { \"title\": {}, \"summary\": {} } }, \"aggs\": { \"sum_of_reviews\": { \"sum\": { \"field\": \"num_reviews\" } }, \"group_of_date\": { \"terms\": { \"field\": \"publish_date\", \"size\": 10 }, \"aggs\": { \"avg_of_reviews\": { \"avg\": { \"field\": \"num_reviews\" } } } } } } 结果 { \"took\" : 17, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : { \"value\" : 2, \"relation\" : \"eq\" }, \"max_score\" : 5.7691345, \"hits\" : [ { \"_index\" : \"bookdb_index\", \"_type\" : \"book\", \"_id\" : \"1\", \"_score\" : 5.7691345, \"_source\" : { \"title\" : \"Elasticsearch: The Definitive Guide\", \"authors\" : [ \"clinton gormley\", \"zachary tong\" ], \"summary\" : \"A distibuted real-time search and analytics engine\", \"publish_date\" : \"2015-02-07\", \"num_reviews\" : 20, \"publisher\" : \"oreilly\" }, \"highlight\" : { \"title\" : [ \"\u003cem\u003eElasticsearch\u003c/em\u003e: The Definitive \u003cem\u003eGuide\u003c/em\u003e\" ] } }, { \"_index\" : \"bookdb_index\", \"_type\" : \"book\", \"_id\" : \"3\", \"_score\" : 5.2062206, \"_source\" : { \"title\" : \"Elasticsearch in Action\", \"authors\" : [ \"radu gheorge\", \"matthew lee hinman\", \"roy russo\" ], \"summary\" : \"build scalable search applications using Elasticsearch without having to do complex low-level programming or understand advanced data science algorithms\", \"publish_date\" : \"2015-12-03\", \"num_reviews\" : 18, \"publisher\" : \"manning\" }, \"highlight\" : { \"summary\" : [ \"build scalable search applications using \u003cem\u003eElasticsearch\u003c/em\u003e without having to do complex low-level programming\" ], \"title\" : [ \"\u003cem\u003eElasticsearch\u003c/em\u003e in Action\" ] } } ] }, \"aggregations\" : { \"sum_of_reviews\" : { \"value\" : 38.0 }, \"group_of_date\" : { \"doc_count_error_upper_bound\" : 0, \"sum_other_doc_count\" : 0, \"buckets\" : [ { \"key\" : 1423267200000, \"key_as_string\" : \"2015-02-07T00:00:00.000Z\", \"doc_count\" : 1, \"avg_of_reviews\" : { \"value\" : 20.0 } }, { \"key\" : 1449100800000, \"key_as_string\" : \"2015-12-03T00:00:00.000Z\", \"doc_count\" : 1, \"avg_of_reviews\" : { \"value\" : 18.0 } } ] } } } ","date":"2020-04-02","objectID":"/104_es_base/:2:2","tags":["Elasticsearch","Kibana","PHP"],"title":"Elasticsearch DSL的PHP写法示例","uri":"/104_es_base/"},{"categories":["后端"],"content":"PHP 代码 // 要事先安装好elasticsearch/elasticsearch扩展包,注意:扩展包要匹配当前使用的Elasticsearch版本 use \\Elasticsearch\\ClientBuilder; $client = ClientBuilder::fromConfig([ 'hosts' =\u003e ['elasticsearch:9200'], 'retries' =\u003e 2, 'handler' =\u003e ClientBuilder::singleHandler() ]); $search = [ // 指定索引 'index' =\u003e 'bookdb_index', // 搜索主体 'body' =\u003e [ 'query' =\u003e [ 'bool' =\u003e [ // `must`里的每个条件都要满足 'must' =\u003e [ // 多字段条件 [ 'multi_match' =\u003e [ 'query' =\u003e 'elasticsearch guide', // 空数组表示搜索任意字段 'fields' =\u003e [] // 也可以指定搜索那些字段 // 'fields' =\u003e ['title', 'summary'] ] ], // 短语前缀条件 [ 'match_phrase_prefix' =\u003e [ // 搜索`title`字段以`elastic`开头的文档 'title' =\u003e [ 'query' =\u003e 'elastic', // 调整单词顺序和不太严格的相对位置,大概是查询的分词之间最多能容纳多少个别的词 'slop' =\u003e 3, // 用来限制查询项的数量，降低对资源需求的强度 'max_expansions' =\u003e 10 ] ] ], // 通配符条件 [ 'wildcard' =\u003e [ // `title`字段以`elastic`开头 'title' =\u003e 'elastic*' ] ], // 正则条件 [ 'regexp' =\u003e [ 'title' =\u003e 'elastic.*ch' ] ], // 范围条件 [ 'range' =\u003e [ // 10≤`num_reviews`≤20 'num_reviews' =\u003e [ 'from' =\u003e 10, 'to' =\u003e 20, // 包括边界值 'include_lower' =\u003e true, 'include_upper' =\u003e true ] ] ] ], // 必须不在`must_not`的条件范围内 'must_not' =\u003e [ [ 'terms' =\u003e [ 'publish_date' =\u003e ['2015-12-04'] ] ] ], // `should`里的条件只要不跟`must`和`must_not`的冲突,那满足`should`的也算(非必须满足) 'should' =\u003e [ [ 'match' =\u003e [ 'publisher' =\u003e 'manning' ] ] ], // 对上面的筛选结果进行补充筛选 'filter' =\u003e [ // 要求存在`authors`字段 [ 'exists' =\u003e [ 'field' =\u003e 'authors' ] ], // 范围条件的另一种写法 [ 'range' =\u003e [ 'num_reviews' =\u003e [ 'gte' =\u003e 12, 'lt' =\u003e 30 ] ] ] ] ] ], // 返回相关部分的标记html 'highlight' =\u003e [ 'fields' =\u003e [ // 键是表示要返回哪些字段的相关标记,值是空对象 'title' =\u003e new stdClass(), 'summary' =\u003e new stdClass() ] ], // 聚合 'aggs' =\u003e [ // 符合全部条件的文件的`num_reviews`字段值的总和,这个总和以`sum_of_reviews`记录下来(这个键名是自定义的) 'sum_of_reviews' =\u003e [ 'sum' =\u003e [ 'field' =\u003e 'num_reviews', ] ], // 分组 'group_of_date' =\u003e [ // 按`publish_date`字段分组 'terms' =\u003e [ 'field' =\u003e 'publish_date', 'size' =\u003e 10 ], // 计算每个小组的`num_reviews`字段平均分 'aggs' =\u003e [ 'avg_of_reviews' =\u003e [ 'avg' =\u003e [ 'field' =\u003e 'num_reviews' ] ] ] ] ] ] ]; echo '\u003cpre\u003e'; var_dump($client-\u003esearch($search)); 输出 array(5) { [\"took\"]=\u003e int(18) [\"timed_out\"]=\u003e bool(false) [\"_shards\"]=\u003e array(4) { [\"total\"]=\u003e int(1) [\"successful\"]=\u003e int(1) [\"skipped\"]=\u003e int(0) [\"failed\"]=\u003e int(0) } [\"hits\"]=\u003e array(3) { [\"total\"]=\u003e array(2) { [\"value\"]=\u003e int(2) [\"relation\"]=\u003e string(2) \"eq\" } [\"max_score\"]=\u003e float(5.7691345) [\"hits\"]=\u003e array(2) { [0]=\u003e array(6) { [\"_index\"]=\u003e string(12) \"bookdb_index\" [\"_type\"]=\u003e string(4) \"book\" [\"_id\"]=\u003e string(1) \"1\" [\"_score\"]=\u003e float(5.7691345) [\"_source\"]=\u003e array(6) { [\"title\"]=\u003e string(35) \"Elasticsearch: The Definitive Guide\" [\"authors\"]=\u003e array(2) { [0]=\u003e string(15) \"clinton gormley\" [1]=\u003e string(12) \"zachary tong\" } [\"summary\"]=\u003e string(50) \"A distibuted real-time search and analytics engine\" [\"publish_date\"]=\u003e string(10) \"2015-02-07\" [\"num_reviews\"]=\u003e int(20) [\"publisher\"]=\u003e string(7) \"oreilly\" } [\"highlight\"]=\u003e array(1) { [\"title\"]=\u003e array(1) { [0]=\u003e string(53) \"Elasticsearch: The Definitive Guide\" } } } [1]=\u003e array(6) { [\"_index\"]=\u003e string(12) \"bookdb_index\" [\"_type\"]=\u003e string(4) \"book\" [\"_id\"]=\u003e string(1) \"3\" [\"_score\"]=\u003e float(5.2062206) [\"_source\"]=\u003e array(6) { [\"title\"]=\u003e string(23) \"Elasticsearch in Action\" [\"authors\"]=\u003e array(3) { [0]=\u003e string(12) \"radu gheorge\" [1]=\u003e string(18) \"matthew lee hinman\" [2]=\u003e string(9) \"roy russo\" } [\"summary\"]=\u003e string(152) \"build scalable search applications using Elasticsearch without having to do complex low-level programming or understand advanced data science algorithms\" [\"publish_date\"]=\u003e string(10) \"2015-12-03\" [\"num_reviews\"]=\u003e int(18) [\"publisher\"]=\u003e string(7) \"manning\" } [\"highlight\"]=\u003e array(2) { [\"summary\"]=\u003e array(1) { [0]=\u003e string(114) \"build scalable search applications using Elasticsearch without having to do complex low-level programming\" } [\"title\"]=\u003e array(1) { [0]=\u003e string(32) \"Elasticsearch in Action\" } } } } } [\"aggregations\"]=\u003e array(2) { [\"sum_of_reviews\"]=\u003e array(1) { [\"value\"]=\u003e float(38) } [\"group_of_date\"]=\u003e array(3) { [\"doc_count_error_upper_bound\"]=\u003e int(0) [\"sum_other_doc_count\"]=\u003e int(0) [\"buckets\"","date":"2020-04-02","objectID":"/104_es_base/:2:3","tags":["Elasticsearch","Kibana","PHP"],"title":"Elasticsearch DSL的PHP写法示例","uri":"/104_es_base/"},{"categories":["后端"],"content":"参考资料 下面的资料使用的Elasticsearch版本较低,有部分功能在当前7.x版本已被废弃,需要有选择地参考和使用 ElasticSearch学习文档 这篇是基础,初学者大概了解下就好,可以当作手册使用 23个最有用的Elasticsearch检索技巧 这篇很重要,帮你快速上手DSL 《Elasticsearch: 权威指南》 基于2.x版 Elasticsearch-PHP php的ES扩展包说明文档 ","date":"2020-04-02","objectID":"/104_es_base/:3:0","tags":["Elasticsearch","Kibana","PHP"],"title":"Elasticsearch DSL的PHP写法示例","uri":"/104_es_base/"}]